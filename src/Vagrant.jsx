/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { DoubleSide, Vector3, GLSL3 } from 'three';
import { Fire } from './Fire';

const vertexShader = /* glsl */`
in vec3 position;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPos;
out vec3 vOrigin;
out vec3 vDirection;
void main() {
  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
  vDirection = position - vOrigin;
  gl_Position = projectionMatrix * mvPosition;
}
`;
const engineUniforms = {
  cameraPos: { value: new Vector3() },
  threshold: { value: 0.001 },
  steps: { value: 255 },
  time: { value: 0 }
};
const Engine = () => {

  const fragmentShader = /* glsl */`
  precision highp float;
  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;
  in vec3 vOrigin;
  in vec3 vDirection;
  out vec4 color;
  uniform float threshold;
  uniform float steps;
  uniform float time;

  vec2 hitBox( vec3 orig, vec3 dir ) {
    const vec3 box_min = vec3( - 0.5 );
    const vec3 box_max = vec3( 0.5 );
    vec3 inv_dir = 1.0 / dir;
    vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
    vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
    vec3 tmin = min( tmin_tmp, tmax_tmp );
    vec3 tmax = max( tmin_tmp, tmax_tmp );
    float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
    float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
    return vec2( t0, t1 );
  }

  mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
  }

  vec3 rotate(vec3 v, vec3 axis, float angle) {
    mat4 m = rotationMatrix(axis, angle);
    return (m * vec4(v, 1.0)).xyz;
  }

  float sdBox( vec3 p, vec3 b ) {
      vec3 q = abs(p) - b;
      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
    }
  
  // polynomial smooth min (k = 0.1);
  float smin( float a, float b, float k ) {
      float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
      return mix( b, a, h ) - k*h*(1.0-h);
  }

  float sdSphere(vec3 p, float r) {
    return length(p)-r;
  }
  vec3 opTwist( in vec3 p )
  {
      const float k = 10.0; // or some other amount
      float c = cos(k*p.y);
      float s = sin(k*p.y);
      mat2  m = mat2(c,-s,s,c);
      vec3  q = vec3(m*p.xz,p.y);
      return q;
  }

  float sdOctahedron( vec3 p, float s) {
    p = abs(p);
    float m = p.x+p.y+p.z-s;
    vec3 q;
        if( 3.0*p.x < m ) q = p.xyz;
    else if( 3.0*p.y < m ) q = p.yzx;
    else if( 3.0*p.z < m ) q = p.zxy;
    else return m*0.57735027;
      
    float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
    return length(vec3(q.x,q.y-s+k,q.z-k)); 
  }
  
  float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
  }

  float sdf(vec3 p) {
    vec3 p1 = rotate(p, vec3(.0, .3, 0.5), .9);
    p1 = rotate(p1, vec3(.0, 1., 0.0), time * 2.);

    // p1 = rotate(p1, )
    float twistedBox = sdOctahedron(opTwist(p1), 0.45);
    for (float i = 0.; i < 5.; i++) {

      float randOffset = rand(vec2(i, 0.));
      float progr = fract(time/ 3. + randOffset * 3.);
      vec3 pos = vec3(sin(randOffset * 2. * 3.1415), cos(randOffset*2.*3.1415), 0.);
      float goToCenter = sdSphere(p - pos * progr, min(0.1, (1. / progr) / 100.));
      twistedBox = smin(twistedBox, goToCenter, 0.1);

    }
    return twistedBox;
  }

  vec3 calcNormal( in vec3 p ) // for function f(p)
  {
      const float eps = 0.0001; // or some other value
      const vec2 h = vec2(eps,0);
      return normalize( vec3(sdf(p+h.xyy) - sdf(p-h.xyy),
                            sdf(p+h.yxy) - sdf(p-h.yxy),
                            sdf(p+h.yyx) - sdf(p-h.yyx) ) );
  }

  void main(){
    vec3 rayDir = normalize( vDirection );
    vec2 bounds = hitBox( vOrigin, rayDir );
    if ( bounds.x > bounds.y ) discard;
    bounds.x = max( bounds.x, 0.0 );
    vec3 p = vOrigin + bounds.x * rayDir;
    vec3 inc = 1.0 / abs( rayDir );
    float delta = min( inc.x, min( inc.y, inc.z ) );
    delta /= steps;
    for ( float t = bounds.x; t < bounds.y; t += delta ) {
      float d = sdf( p );
      if ( d < threshold ) {
        color.rgb = vec3(1.) ;
        color.rgb = vec3(1.);
        vec3 normal = calcNormal(p);
        color.rgb = normal;
        float diff = dot(vec3(1.), normal);
        color.rgb = vec3(diff);
        float fresnel = pow(1. + dot(rayDir, normal), 1.);
        color.rgb = vec3(fresnel);
        color.rgb = mix(color.rgb, vec3(1., 1., 0.), -fresnel);
        color.a = 1.;
        break;
      }
      p += rayDir * delta;
    }
    if ( color.a == 0.0 ) discard;
  }
  `;

	useFrame(({clock, camera}) => {
		engineUniforms.time.value = clock.elapsedTime
    engineUniforms.cameraPos.value = camera.position
	});

	return <group position={[3.2, 1, -1.95]} scale={[4, 3, 3]}>
		<pointLight
      // castShadow
      // shadow-mapSize-width={512}
      // shadow-mapSize-height={512}
      // shadow-camera-far={10}
      // shadow-bias={-0.05}
      // shadow-camera-left={-5}
      // shadow-camera-right={5}
      // shadow-camera-top={5}
      // shadow-camera-bottom={-5}
      args={['blue', 10, 30, 4]}/>
    <mesh layers={1}>
      <boxGeometry args={[1, 1, 1]} />
      <rawShaderMaterial 
        glslVersion={GLSL3} 
        side={DoubleSide} 
        uniforms={engineUniforms} 
        fragmentShader={fragmentShader} 
        vertexShader={vertexShader}  
        transparent={true}
      />
    </mesh>
	</group>

}



const Sphere = () => {
	const sphereRef = useRef();

	useFrame(({ clock }) => {
		sphereRef.current.position.y += Math.sin(clock.elapsedTime) / 700.;
		sphereRef.current.rotation.y += Math.cos(clock.elapsedTime) / 20.;
	});

	return (
		<mesh position={[0.6, 3.72, 1.2]} castShadow={true} receiveShadow={true} ref={sphereRef}>
			<icosahedronGeometry args={[0.1, 0]} />
			<meshStandardMaterial color={"white"} />
		</mesh>
	);
};


export function Vagrant(props) {
  const { nodes, materials } = useGLTF('/vagrant.glb')
  return (

    <group {...props} dispose={null}>
      <Engine />
      <Sphere />
      <Fire position={[1.2, 3.6, 4.5]}/>
      <group
        position={[0.67, 0.55, 0.45]} 
        scale={[2.58, 2.08, 2.08]}
      >
        <primitive object={nodes.spine} />
        <group position={[0, -0.01, 0]} rotation={[Math.PI / 2, 0, 0]} scale={[0.39, 0.48, 0.48]}>
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_1.geometry} material={materials.eyes} />
          <pointLight 
            castShadow 
            position={[-.1,.6, -3.6]}  
            args={['#E7D400', 5, 3.5]}
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
            shadow-camera-far={30}
            shadow-bias={-0.01}
            shadow-camera-left={-5}
            shadow-camera-right={5}
            shadow-camera-top={5}
            shadow-camera-bottom={-5}
            />
            		{/* <mesh receiveShadow castShadow position={[-.1,.7, -3.6]}>
			<sphereBufferGeometry args={[0.1]} />
			<meshBasicMaterial color="white" />
		</mesh> */}
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_2.geometry} material={materials.mask} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_3.geometry} material={materials.hood} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_4.geometry} material={materials.pants} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_5.geometry} material={materials.shirt} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_6.geometry} material={materials.bracelents} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_7.geometry} material={materials.shoes} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_8.geometry} material={materials.sole} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_9.geometry} material={materials.gloves} />
          <mesh castShadow receiveShadow geometry={nodes.Sphere002_10.geometry} material={materials.shawl} />
        </group>
      </group>
      <mesh castShadow receiveShadow geometry={nodes.Cube.geometry} material={materials.rust} position={[0.19, -1.63, -1.34]} rotation={[0, 0.12, 0]} scale={[4.83, 0.15, 1]} />
      <mesh castShadow receiveShadow geometry={nodes.Cylinder.geometry} material={nodes.Cylinder.material} position={[-1, 2.38, 4.5]} />
      <mesh castShadow receiveShadow geometry={nodes.Plane_1.geometry} material={materials['upper hood']} />
      <mesh castShadow receiveShadow geometry={nodes.Plane_2.geometry} material={materials['lower hood']} />

    </group>
  )
}
useGLTF.preload('/vagrant.glb')
